# 设计模式入门
欢迎来到设计模式世界。
## 先从简单的模拟鸭子应用做起
小杨在公司做了一套成功的鸭子游戏：SumUDuck。游戏中会出现各种鸭子，一边游泳一边呱呱叫。

* 鸭子超类（SuperClass）
```
abstract class Duck {
    quack(){
        // 呱呱叫
    }
    swim(){
        // 游泳
    }    
    /*每个鸭子外观不同，所以方法是抽象*/
    abstract display();
}
```
* 绿头鸭
```
class MallardDuck extends Duck {
    display() {
        // 外观是绿头
    }
}
```
* 红头鸭
```
class ReadHeadDuck extends Duck {
    display() {
        // 外观是红头
    }
}
```

## 现在我们得让鸭子能飞
我们只需要在`Duck`类上加上`fly()`方法，然后所有鸭子都会继承并且会飞。
但是这个时候问题出现了，并非所有的鸭子都能飞，比如大黄鸭=。=！

这个时候小杨想到**继承**，大黄鸭可以覆盖`fly()`方法什么都不做。但是如果以后加入木头鸭子呢。

> 所有使用继承提供`Duck`的行为有很多缺点：改变会动一发而动全身，很难知道所有子类的全部行为等。

## 利用接口如何
小杨想到可以把`fly()`方法从超类中提取出来，放进一个`FlyAble`接口中，这么一来只有会飞的鸭子才实现此接口。
同理可以设计一个`QuackAble`接口，因为不是所有鸭子都会叫。
> 这真是一个超笨的主意，这样一来重复的代码会变很多，假如覆盖几个方法只是差劲，那么有 48 个鸭子需要稍微修改一下飞行的行为呢？！

## 把问题归零
> 设计原则：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。

> 把会变化的部分取出并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。


## 设计鸭子的行为
> 设计原则：针对接口编程，而不是针对实现编程。
我们用接口来实现每个行为，比方说`FlyBehavior`和`QuackBehavior`，而鸭子类不会负责实现这两个接口，反而是由我们制造一组其它类专门实现。

![part1_01.png](imge/part1_01.png)